---
title: KIP-74 - Staking Module Part 1 (1)
sidebar_position: 2
slug: /a932c6e4-8516-404a-adfa-c1a7a765dcf1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';



## Locking Coins & Earning Block Reward {#3d4a4f2355a24c00b9d639714dbc191a}


### Overview {#88904b8eea514d11bd46f168c80d5104}


Purpose of staking is to increase value of assets locked at stake that can be slashed if the validators misbehave and thus secure the network in exchange for `%` of block and fee rewards generated by the network. Initially we will NOT have a slashing, thus the main goal of our new staking module is to enable passive income generation from locking up tokens to vouch for the honesty of the validators.


Token delegators on KIRA earn block and fee rewards in proportion to the value of their stake. In short - the more tokens of higher value you stake - the more you will be earning. There exist two types of rewards - block rewards (from KEX inflation) and fee rewards (from execution fees[broken link]), both of those types of rewards will be distributed in a slightly different manner to achieve two distinct goals - proportionate rewards distribution & encouraging fair distribution of stake among as many nodes as possible.

- The block rewards distribution will be proportionate to the value of all the staking tokens bonded to all validators (fulfilling our first goal) to reward delegators with more money for taking higher risk of slashing. _(this is similar to cosmos rewards distribution)_
- Remainder of the fee rewards NOT distributed to a validator as per KIP-73[broken link] must be distributed to delegators thus land in the Staking Pool. The fee rewards are proportionate to stake but not in respect to all stake distributed to all validators - but in regards to a stake bonded to individual validator nodes (this is guaranteed by the fee distributor KIP-73 and fulfills our second objective). In other words if there are `N` validators but everyone delegated all staking tokens to just 1 validator, then all delegators would be getting only `1/N` of all remaining fee rewards and missing on `(N-1)/N`. Optimal strategy to maximise fee rewards for the delegator is thus to equally split their stake among all validators _(this is similar to polkadot rewards distribution)_

![](./813946695.png)


_NOTE: Staking pools will be assigning rewards to delegators based on the weight of their local stake (in respect to other delegators in the pool) thus simplifying our implementation. Once the rewards land in the staking pool we will not have to care what % of global stake any particular delegation represents._


### Token Rates Registrar (modification) {#6dc62b3dc8a841e781b88c51f242f5a5}


KIRA allows to stake ANY token (**NOT just KEX**) and for that reason we need to:

- Set a rewards cap for each token so that no one can print infinite amount of any particular staking token and claim all the rewards. The Governance will be able to manipulate interest rates for staking foreign tokens by simply modifying `stake_cap`, this way we do NOT need to worry about how much any particular token is worth in terms of USD or KEX.
- Define a minimum delegation for each token to prevent a dust spam attacks that would massively delay the block production

To make things simpler, lets begin by adding extra fields to an already existing Token Rates Registrar[broken link] in order to map a token name with its “staking” value in terms of KEX (similarly as we did it for its “fee” value) and maximum rewards in % share that can be claimed by its stakeholders: (Alternatively a new registrar can be created, just without fields already present in token rates registrar)


```json
[ {
		"denom": "ukex",       // token denom MUST be present in the Token Aliases Registrar  [CAN NOT BE MODIFIED - FOR ukex ONLY]
		"fee_rate": 1.0,       // paying 1 ukex in fees is equivalent of paying 1 ukex        [CAN NOT BE MODIFIED - FOR ukex ONLY]
		"stake_cap": 0.50,     // 50% of all block & fee rewards go to KEX delegators         [CAN NOT BE LESS THEN 50% - FOR ukex ONLY]
    "stake_min": 100,      // can't stake less than 100 ukex                              [MUST BE GREATER THAN 0 - FOR ANY TOKEN]
		"fee_payment": true,   // can be used as fee token                                    [CAN NOT BE MODIFIED - FOR ukex ONLY]
		"stake_token": true    // can be used as staking token                                [CAN NOT BE MODIFIED - FOR ukex ONLY]
	} {
		"denom": "xbtc",
		"fee_rate": 175885.0,  // paying 1 satoshi in fees is equivalent of paying 175'885 ukex for a fee transfer
		"stake_cap": 0.251,    // 25.1% of all rewards go to BTC delegators
    "stake_min": 10000,    // can't stake less than 10k sats
		"fee_payment": true,   // can be used as fee token
		"stake_token": true    // can be used as staking token
	}, {
		"denom": "xeth",
		"fee_rate":   0.0000012,  // paying 1 wei in fees is equivalent of paying 0.0000012 ukex
		"stake_cap": 0.1,         // 0% of all rewards go to ETH delegators, because stake_token is set to false
    "stake_min": 8333333334,  // can't stake less than 8'333'333'334 wei
		"fee_payment": true,      // can be used as fee token
		"stake_token": false      // can NOT be used as staking token
	},{ ... }, ... ]
```


Whenever adding entry or updating Rates Registrar, the sum of all reward caps MUST be equal or smaller than `1.0` (`100%`) and it should NOT be possible for the `stake_token` property to be set to `true` if cumulative `stake_cap`  exceeds `1.0`.  If the `stake_token` property for a specific token is set to `false` then it should NOT be possible to stake said token (only ustaking should be possible) and no rewards should be distributed (equivalent of fee rate set to 0).


**Token can be a staking token IF and only IF it is present in the** **token aliases registrar**[broken link]**, otherwise we will not know what is the number of decimals in the lowest denomination. Removal of a token from the token aliases registry should also disable it for staking by setting** **`stake_token`** **and** **`fee_token`** **properties to** **`false`****.** 


### Staking Tokens {#91aa73ec458049b3947f94d2fb5da70f}


Purpose of staking is to increase value of assets locked at stake that can be slashed if the validators misbehave and thus secure the network in exchange for `%` of block and fee rewards generated by the network. To know how many KEX should be distributed to all delegators we should create network properties[broken link] that will define KEX inflation `%` rate, a corresponding inflation period over which the current supply should be increased and the default locking period applied to all tokens being staked.

- `inflation_rate` - KEX inflation percentage `X` defined as decimal value.
	- Default: `0.18` that is equivalent of `18%`,
	- Minimum: `0` - `0%`
	- Maximum:  `0.5` - `50%`,
- `inflation_period` - period of time (in seconds) over which current KEX supply is inflated by a percentage corresponding to the `inflation_rate`
	- Default:  `31'557'600` - `1 year`,
	- Minimum: `2'629'800` - `1 month`
	- Maximum: `31'557'600` - `1 year`
- `unstaking_period` - period of time (in seconds) it takes to unstake any of the staked tokens
	- Default `2'629'800` - `1 month`
	- Minimum `604'800` - `1 week`
	- Maximum `31'557'600` - `1 year`

_NOTE: For example if the KEX token supply at the time_ _`T1`_ _is_ _`300’500’000`__, inflation rate is set to_ _`0.15`_ _while the inflation period is_ _`31'557'600`_ _then ALL delegators who are staking their coins for the period of_ _`T2-T1 = 3'600 seconds`_ _should be eligible to cumulatively claim_  _`(3'600 * 300’500’000 * 0.15)/31'557'600 ~= 5142 KEX`__. To make distribution of all staking rewards simpler we will utilize_ _**Staking Pools Registrar**_ _that will be created by each individual validator and responsible for distributing coins to individual delegators._


#### Liquid Stakes {#a10a0a6595b24230a3b9d071222896d9}


Main difference between staking tokens on KIRA and other networks is that all staking coins must remain liquid (transferable) in the form of automatically issued 1:1 staking derivatives. This will allow us to massively reduce the complexity of the staking module & rewards distribution as it is analogical to how the uniswap liquidity pool tokens work.


We will treat every individual validator as as the equivalent of a “liquidity pool”, so when `n` tokens `XYZ` are staked to a validator `V1` we should issue `n` token named`V1_XYZ` and deposit them to the account which “locks/stakes” their coins, the `V1_XYZ` coins can then be freely moved while the underlying `XYZ` will remain bonded to `V1`. If the `V1` were to be slashed in the future the bonded coins could be moved to the gov spending pool or destroyed while the `V1_XYZ` representing the remaining stake would simply lose their `1:1` peg (equivalent of impermanent loss on uniswap). For example if `50%` of `V1` bonded `XYZ` is slashed then unstaking of `2 V1_XYZ` would only return `1 XYZ`. 


> IMPORTANT: It should only be possible to stake tokens IF and only IF validator status is ACTIVE. Slashing in KIRA will result in permanent JAIL which will make our peg calculations massively simpler then if we had to constantly monitor state of the bonded tokens “pool”. Furthermore block & fee rewards will only be distributed to staking pools operated by validators who remain ACTIVE - as the action will ONLY be triggered at the time of block production. 


#### Staking Pools Registrar {#8dbae87bfcb54cf190535e2c5aaa850d}


Now that we know, that if a user holds `1 V1_XYZ` it is the same as as if he was staking `1 XYZ` to a validator `V1`. Now we need to have a way to allow the delegators claim the block and fee rewards in proportion to the derivative tokens hey have. We will begin by creating a registrar / list of staking pools mapped to each individual validator, to which block and fee rewards will be deposited every time a validator proposes a block (similar to how KIP_73[broken link] triggers its rewards distribution) and from where delegators will be able to claim their coins. Finally we will make each validator responsible for creating their own staking pool and managing it (for example changing commission, enabling, disabling etc.), with a notion that 1 validator can only have 1 staking pool.


The staking pool registrar will have following sections:

- `id` - short, positive, iterative integer & unique identifier of the staking pool, will be used as part of the prefix in the denom names of the staking derivatives
- `enabled` - will allow validator to shutdown the pool for staking any additional tokens into it, if set to `false` only unstaking should be possible and NO compounding should be allowed. If the pool is disabled it should also not accumulate any new rewards.
- `bonds` - responsible for storing information in regards to how many tokens (`amount`) of a specific `denom` were deposited (staked) to the pool and how many staking derivatives (`shares`) were issued in exchange. If in the future the tokens were to be slashed then `shares` would remain the same, but the corresponding `amount` would decrease. The `bonds` property allows us to calculate what percentage of all coins in the pool any particular delegator holds and calculate the exact amount of rewards that the delegator is eligible for.
- `delegators` - for every staking derivative holder (who holds no less than `stake_min` amount of a particular token) we need to track how many rewards they accumulated as well as how many derivatives they are holding to know how much rewards we should credit them every time the validator produces a new block.
	- `balances` - list of tokens that the pool contributor either holds on his account  (`shares`) or is eligible to claim from the staking pool because he earned them as rewards (`claims`). Note that just because delegator owns a particular derivative does not mean that the reward will be in the same token - rewards can be in many different tokens so the corresponding entry might not even exist! In such case a new entry will be added with `shares`set to `0` and the `claims` set to the number of tokens that was earned. Note that the balances can not only store information about native tokens but also the staking derivatives themselves - this way we do NOT need to transfer to users anything and simply update the `claims` records in balances array.
		- `compound`  - For any particular token which is stakeable as defined by Token Rates Registrar the rewards can be compounded, this means that `claims` in the form of rewarded stakeable token should be set to `0` and the corresponding derivative asset created. The newly issued derivatives should then be credited as `claims` but to a separate `V<id>_` prefixed record in the balances array.
- `validator` - rewards to a validator include a commission (from block rewards) and for that reason we need to persist information about his address and accumulated rewards. This field will also give us information about self bonded stake - so that delegators can see in the explorer how much of his own money the validator is contributing. Other then that the `validator` property is analogical to the `delegators`. We might also modify KIP-73, to instead of directly sending the `validators_fee_share` into validator account - add them to his balances in the pool, so that no token transfers happen and the validator can compound his earnings.
	- `comission` - validator besides the `validators_fee_share` from the KIP-73 distributor module must also earn a **self defined percentage commission, but ONLY from the block rewards and NOT from any fee rewards**. The `commission` should have a minimum value of `0.01` (`1%`) and a maximum value of `0.5` (`50%`) so that the validators can’t over-charge or undercharge the delegators and so that there can be no validators charging `0%` and thus forcing operations of smaller validators to become unprofitable.
	- `balances` - same as delegator balances
- `unstake` - is required to track the unbonding process. First destroy derivatives of the delegator and then allow him to claim underlying shares after the `expiry` period. (Of course we need to take into account that the tokens might have been slashed - this can be monitored using information from the `bonds` field). When the tokens are being unstaked we should NOT allow them to accumulate rewards for the delegator.
- `timestamp` - will be used to track time period for which staking pool should receive its block & fee rewards share. The `timestamp` MUST change every time the new block is produced by the owner of the staking pool and new tokens are issued to it. The value `timestamp` MUST be set to `0` IF the validator stops being ACTIVE. IF the validator re-activates the node then the `timestamp` should be set to the current block timestamp in which the node was re-activated. This way we do not pay out rewards if the validator is not actively participating in the consensus or at least attempting to participate.

**Example Staking Pool Interface**


```json
{
			"id": 1,                       // globally unique, iterative staking pool ID number (will be used as token name prefix)
      "enabled": true,               // allow validator to enable or disable the pool, disabled pool does NOT accumulate rewards, does NOT allow for staking, but allows unstaking and claims
      "timestamp": <uint>,           // UNIX timestamp, the last time rewards batch was distributed and all delegators balances updated
			"bonds": [                     // list of tokens locked to the pool
				{
					"denom": "ukex",           // name of the token bonded (locked in the pool)
					"amount": <uint>,          // cumulative amount of a token bonded to the staking pool
          "shares": <uint>           // number of staking derivatives created by the staking pool (unless shlashing happens this will be the asme as amount)
				}, {
					"denom": "xeth",
					"amount": 123456789,       // NOTE: Unless slashing happens, the ammount & derivatives value will be the same
					"shares": 123456789 }, { ... }, ... ],
      "delegators": [                // Registry mapping delegaotr address to tokens & rewards balances
				{
					"address": "kiraXXX...YYY", // Delegator address,                       
          "balances": [
						"ukex": {
	            "compound": <bool>,     // Defines if the rewards should be compounded (reward token must be a staking token in such case)   
							"shares": <uint>,       // amount of V1_ukex derivatives that the delegator owns
							"claims": <decimal>     // amount of unclaimed ukex rewards
						},
						"xbtc": {
              "compound": true,
							"shares": 10000,
							"claims": 0.0
						},
						"V1_xbtc": {
              "compound": false,
							"shares": 0,           // amount of V1_V1_xbtc derivatives that the delegator owns (NOTE: RECURSION IS POSSIBLE, if governance whitelist derivative for staking)
							"claims": 135.1        // amount of unclaimed V1xbtc rewards (this example stores compounded rewards)
						}, { ... }, ...
					] }, { ... }, ...
			],
     "validator": {
       "address": "kiraXXX...YYY",    // address of validator who created staking pool
			 "commission": <decimal>,       // percentage (e.g. 0.1 == 10%) commission that the validator charges from all block reward
       "balances": [
           "ukex": {                  // token name 
              "compound": <bool>,     // Defines if the rewards should be compounded (if the reward token is also a staking token)  
							"shares": <uint>,       // amount of V1_ukex (self bonded tokens)
							"claims": <decimal>     // amount of unclaimed ukex rewards
						},
					"xbtc": {                   // token name 
              "compound": true
							"shares": 1000,       // amount of V1_xbtc (self bonded tokens)
							"claims": 3.14        // amount of unclaimed xbtc rewards
						}, { ... }, ...
			]},
			"unstake": [
				{
					"address": "kiraXXX...YYY",
					"shares": <uint>,
					"expiry": <unix-timestamp>
				}, { ...	}
		]
}
```


To guarantee fair rewards distribution we need to update staking pool every time one of the following events occurs:

- Validator who created staking pool proposes a new block
	- Issue new KEX tokens and deposit them into staking pool (see Block Rewards Distribution section for details)
	- Deposit fee rewards to the staking pool as as per KIP-73 (this can include validator rewards, see Fee Rewards Distribution section for details)
	- Update `timestamp` to current block time
	- Calculate outstanding rewards to all delegators and validator, then update all records accordingly
		- Compound tokens for delegators that set `compound` to true (issue new derivatives, deposit them to the staking pool and set `claims` for those derivative - no transfers to delegators needed and we can do it cumulatively for all tokens at once). Note here that compounding should occur only if claims ammount exceeds `stake_min` to prevent dust spam.
		- Add new rewards to `claims` only if `compound` is set to false
- User deposits tokens to the pool (`staking-pool-deposit-tx`)
	- Issue corresponding staking derivative tokens and transfer them to the delegator address
	- Update `balances` in delegators array or validator property (depending who is staking)
	- If delegator staked the same tokens before, then compound or withdraw outstanding rewards depending on preferences
- Delegator transfers staking derivatives between two accounts (`bank-tx`)
	- Compound or withdraw outstanding rewards depending on preferences (`compound` set to `true/false`)
	- If `shares` are less then `stake_min` after the operation then delete record entirely from the delegator account `balances`
	- If all balances of a particular delegator are deleted then delete the entire delegator record
- Delegator attempts to claim all the outstanding rewards (`staking-pool-claim-rewards-tx`)
	- If the `compound` is set to true, then compound
	- If the `compound` is set to false then withdraw rewards to delegator account
- Delegator attempts to undelegate his coins  (`staking-pool-undelegate-tx`)
	- Destroy delegator derivatives
	- Create unstaking record and set expiry to `current_block_time + unstaking_period`
	- Trigger outstanding rewards claims / compounds
- Delegator attempts to withdraw his unstaked coins after `expiry` passed (`staking-pool-claim-stake-tx`)
	- Return the coins 1:1 to undelegator address (unless slashing happened, then a proportionate % - To Be Implemented later with KIP-75)
	- Trigger outstanding rewards claims / compounds
- Validator upserts staking pool (`staking-pool-upsert-tx`)
	- If pool does not exist then create it
	- If pool exists then trigger outstanding rewards claims / compounds, then apply changes

> IMPORTANT: Field `balances` should ONLY contain records that either poses outstanding `claims` or the `shares` in amount is no less than `stake_min` amount, it should NOT be possible to send  `staking-pool-deposit-tx` if the amount is too small. In the case of derivative token transfers, where as the result of transfer the amount drops below  `stake_min` we should credit the `claims` and delete the record EVEN if `compound` property is set to true and would result in exceeding `stake_min`. We must expect that someone could create almost infinite number of accounts with small stake balances and halt or otherwise massively delay the block production because of it!


### Block Rewards Distribution {#261136d64d614d009b720be024b5a351}


Thanks to the **Staking Pool Registrar**, **Token Rates Registrar Modifications,** and new inflation related **Network Properties**, we have all the data that will allow us to calculate  and distribute rewards to individual staking pools. To limit number of operations required for processing, in each block we will ONLY update unclaimed (`claims`) balances of tokens in the staking pool of the validator that is currently proposing the block. We will ignore staking pools of all other validators, this mechanism will be similar to KIP-73[broken link] fee rewards distribution. 


**Pseudo algorithm**

1. Calculate time period `P` that passed since the last time the block rewards were deposited to the staking pool `P = (current-block-time - timestamp)`,
	1. **If** **`P`** **is less or equal to** **`0`****, or greater than** **`unstaking_period`****, then do NOT issue any new KEX tokens to the staking pool and set the** **`P`** **to** **`current_block_time`****. (To prevent all possible edge cases where delegators would be able to migrate the stake before validator proposes another block / prevent any possible timestamp manipulation exploits).** Notice here that this rule is essential because we do not store information when exactly the tokens were staked to the pool and in what particular amount.
2. For each token in the `bonds` array calculate total amount of all bonded coins that exists to get `total_bonded_supply` by iterating over all existing staking pools and summing up `amount`.
	1. _NOTE: It might be good to store the_ _`total_bonded_supply`_ _for each token in some registry on-chain (E.g. Token Rates Registry) so that access to those variables is easy and can be queried without iterating over list of all staking pools (as there can be hundreds or thousands of those). In such case we should also be updating that registrar every time new tokens are bonded or unbonded to save a lot of processing & I/O operations time!_
3. Calculate block rewards that should be credited to the staking pool for the time period `P` according to the inflation network properties
	1. Get inflation per second `Ips = (total_ukex_supply * inflation_rate) / inflation_period`. **Notice here that we will be inflating entire KEX supply, but only granting rewards to those who stake tokens, this way delegations will be encouraged by being more profitable the smaller total number of tokens is staked.**
	2. Multiply time period `P` by inflation per second `Ips` to get total block rewards `Tbr` for the time span.
	3. Calculate what fraction of the `Tbr` the staking pool is eligible for, by iterating over each token in `bonds`
		1. Divide `amount` by a `total_bonded_supply` of the specific token to get global share (`Gs = amount / total_bonded_supply`), that is percentage of all stake bonded to all validators
		2. Multiply global share `Gs` by a `stake_cap` of a specific token to get a rewards share (`Rs = Gs * stake_cap`), that is a percentage of all block rewards that the bonded tokens are eligible for
		3. Multiply rewards share `Rs` by total block rewards `Tbr` to get pool block rewards for a token in terms of `ukex` amount `Sbr = Rs * Tbr`
	4. Sum all `Sbr`’s together to get the pool block rewards `Pbr` amount of `ukex` that should be printed and deposited to the staking pool.
	5. Make absolutely sure that `Pbr` is smaller or equal to `Tbr` (Otherwise something must have been wrong with our calculations. The case where `Pbr` equails `Tbr` would occur only if all staking tokens in existence were deposited and staked to only 1 validator)
4. Issue and deposit amount of `ukex` equal to `Pbr`, into our staking pool
	1. Grant to validator amount `Br * validator.commission`                           [ see Staking Rewards Distribution section for more details ]
	2. Split between delegators amount `Br * (1 - validator.commission)`     [ see Staking Rewards Distribution section for more details ]

### Fee Rewards Distribution {#1985e6b592084cc7870aad35005502a8}


The fee rewards (`Fr`) distribution does NOT require any complex calculations and does NOT depend on the stake accumulated in the staking pool. In each block we will simply deposit `Pfr = Fr*(1-validators_fee_share)` of accumulated fees (default `50%`) from the  KIP-73[broken link] that are not meant for the validator to the staking pool. It should be noted that `Pfr` will consist of MANY different tokens and not just KEX. We might also modify KIP-73  Distributor Module to deposit all tokens into the staking pool, and split the rewards between validator and delegators.


### Staking Rewards Distribution {#80ab163baa064cda81221f496fcd6c94}


 Once the validator `commission` is paid along his `validators_fee_share` then we can treat the validator and delegators in exactly same manner when calculating any outstanding rewards. It should be noted that the validators can stake their own tokens to themselves! The block and fee rewards distributed to the staking pool in a given block must be split between the validator and all his delegators in proportion to the delegators stake. To do this we need to update `claims` amounts in the `delegators` and `validator` balances array for each token that was rewarded to the staking pool.


**Pseudo algorithm**

1. Calculate cumulative delegator rewards `Dr` in all tokens that were deposited to the pool after the validator `commission` and his `validators_fee_share`
2. For each delegator in `delegators` array or validator (if he self delegates) calculate their pool share
	1. For each stakeable token (as defined by Token Rates Registry) in the `balances`
		1. Divide deleagatoer `shares` (or `claims` if the token was compounded but the derivative itself is not stakeable) by a total of all bonded shares of a particular token `bonds[<denom>].shares` to get delegator token share `Dts` in the pool
		2. Multiply `Dts` by the `stake_cap` of that particular token to get delegator rewards token share `Rts = Dts  * stake_cap`
	2. Sum all `Rts` of a delegator to get a final delagator rewards share `Drs`
3. For each reward token update multiply its amount by `Drs` and add the value to corresponding `claims`. If the record for a specific token does NOT exist, then create it.
4. If `claims` amount of any stakeable token is non `0` and user set `compound` to `true` for that token then issue staking derivative to the staking pool, set the value of original claim to `0` and set the `claim` value of the derivative record to the same amount. Note that compounding should occur only if rewards equal to no less than `stake_min` and depositing newly created derivatives should happen only once - cumulatively for each token.

_NOTE: User holding derivatives on this account (__`shares`__) or owning them as_ _`claims`_ _as result of compounding should be treated exactly the same way while calculating the rewards that the delegator is eligible to receive - otherwise the compounding would not work._ 


_NOTE 2: The delegators and validator section in the staking registrar are separated so that we can easily distinguish self bond as well as dispose of dust when the delegator balance drops below predefined minimum (without deleting validator address). We can optionally keep validator stake data in delegators array along all other records with a notion that we need to add all other extra fields and store them somewhere else - address, commission._ 


### Unstaking {#5a59e338851e44be80351a852451ccf1}


All holders of staking token derivatives (`V<ID>_XYZ`) must be provided with option to unstake underlying staking tokens`XYZ` that they own. We will achieve this by allowing derivative holder to send `unstake-tx` which will destroy specified amount of their derivative token, auto-claim the remaining rewards in the `delegators` record and create a new record in `unstaking` field with a corresponding `expiry` set to `current_block_timestamp + unstaking_period`. Once the `expiry` period passes the delegator should be able to send `claim-stake-tx` to receive underlying tokens. The `claim-stake-tx` should be generic and return all tokens being ustaked at once, so that it does NOT need to be called individually for each unstaking record (which there can be many). To prevent spam, the minimum amount that can be unstaked should NOT be lower than `stake_min` as defined by **Token/Interest Rates Registrar** and te remaining amount of `shares` in the `balances` should also NOT be smaller then `stake_min` - otherwise the tx should fail.


### Transactions & Queries  {#bc28ef57b8cb4edaa77b73915a791bb6}


List of essential transactions & queries

- `query-interest-rates` - (optional if Token Rates Registrar is Modified), used to query interest rates of all staking tokens
- `staking-pool-upsert` - add or update staking pool - can only be called by an ANCTIVE validator, and is used to create the pool or edit it, e.g. setup/change comision. We should have a dedicated permission to allow sending this tx.
- `query-staking-pools` - list id’s of all available stking pools and their corresponding validators
	- `--validator` - if validator flag is set display only one staking pool corresponding to a specific node address
	- `--id` - if flag is set display only one staking pool corresponding to a specific pool id
- `staking-pool-deposit` - lock `XYZ` token to a specific staking pool by id or validator address and immediately return back a corresponding derivative `V<id>_XYZ`. This transaction can also be used to set `compound` to true or false.
- `query-delegations` - query all delegations and rewards by a delegator address and specific pool id / validator address
- `staking-pool-claim-rewards` - claims rewards by the specific pool id / validator address
- `staking-pool-undelegate` - adds record to `unstake`, triggers rewards claim & destroys `V<id>_XYZ` tokens
- `query-undelegations` - query all the un-delegation records for a specific kira account from a specific validator
- `staking-pool-claim-stake` - returns to delegator all tokens after `expiry` period passed

### Notes {#5cf2f88db297470cbf029b57a129ba1b}


We can add one more protection to prevent dust rewards spam attack - a network prop called `max_delegators` — defining a maximum number of delegator records that each individual staking pool can have (for example 1'000 as default). If the number of records hits max then we can instantly "unstake" smallest delegator, grant him all outstanding rewards and replace that record with a new record with a higher balance.


For this type of instant undelegation to occur the person that will replace existing delegator will need to have minimum 10x more of each coin that the original delegatpr with the smaller balance in the staking pool. (to prevent whales from pushing out smaller delegators away from good validators). The multiplier (10x) can be called `min_delegation_pushout` and be configurable in the network properties. This way we can enforce number of delegators to not grow too large and spam the network state.

